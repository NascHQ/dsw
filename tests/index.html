<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>DSW Tests</title>
</head>
<body>

    <style>
        html, body {
            margin: 0;
            height: 100%;
            background: #ffd;
            font-family: Helvetica, Arial, sans-serif;
        }

        *, *:before, *:after {
            box-sizing: border-box;
        }

        #status {
            float: left;
            width: 25%;
            border-left: solid 1px black;
            margin: 0;
            padding-left: 5px;
        }

        #status li.title {
            font-size: 2em;
            font-weight: bold;
            padding-top: 22px;
            padding-bottom: 22px;
        }
        #status li.title:before {
            content: "";
        }

        #status li {
            padding-left: 20px;
        }

        #status li:before {
            content: "◷ ";
            position: absolute;
            left: 10px;
        }
        #status li:not(.passed):not(.failed):not(.title):before {
            font-size: 1.3em;
            margin-top: -5px;
        }

        #status li.passed:before {
            content: "✔ ";
            color: green;
        }

        #status li.failed:before {
            content: "✖ ";
            color: red;
        }

        #testPage {
            float: right;
            width: 75%;
            height: 100%;
            border: none;
            border-left: solid 1px black;
            background: -moz-linear-gradient(-45deg,  #f0f0f0 0%, #d2d3d5 40%, #eff0f2 100%);
            background: -webkit-linear-gradient(-45deg,  #f0f0f0 0%,#d2d3d5 40%,#eff0f2 100%);
            background: linear-gradient(135deg,  #f0f0f0 0%,#d2d3d5 40%,#eff0f2 100%);
            filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#f0f0f0', endColorstr='#eff0f2',GradientType=1 );
            font-family: Helvetica, Arial, sans-serif;
        }
    </style>

    <ol id="status">
        <li class="title">Tests</li>
    </ol>
    <iframe src="" frameborder="0" id="testPage"></iframe>

    <script>

        var steps = {
            ok: 0,
            fail: 0
        };
        var step = null;

        function addStep (step, status) {
            var item = document.createElement('li');
            item.innerHTML = step;
            //item.classList.add(!status || status == 'ok' || status === true? 'ok': 'fail');
            document.getElementById('status').appendChild(item);
            item.ok = function () {
                this.classList.add('passed');
                steps.ok++;
            };
            item.fail = function () {
                this.classList.add('failed');
                steps.fail++;
            };
            if (status === false) {
                item.fail();
            }
            if (status === true) {
                item.ok();
            }
            return item;
        }

        /*
        - load test page
        - wait for sandbox to load
        - then wait for DSW register to finish
        - then reload sandbox page
        - then wait for sandbox page to load
        - then get dsw status
        */

        var traced = {};
        var tracing = {}
        var iframe = document.getElementById('testPage');
        const SANDBOX_URL = 'http://localhost:8888/';

        function traceReceived (event) {
            traced[event.data.trace.src] = event.data.trace;
            if (tracing[event.data.trace.src]) {
                tracing[event.data.trace.src](event.data.trace);
            }
        }

        function sendMessage (message) {
            return new Promise((resolve, reject)=>{
                var messageChannel = new MessageChannel();
                messageChannel.port1.onmessage = function messageReceived (event) {
                    if (!event.data) {
                        reject('No data arrived');
                        return;
                    }
                    if (event.data && event.data.acknowledged !== void(0)) {
                        resolve(event.data.acknowledged || false);
                        return;
                    } else {
                        if (event.data.trace) {
                            traceReceived(event);
                        }
                    }
                    resolve(event.data);
                };

                document.getElementById('testPage')
                    .contentWindow
                    .postMessage(message, '*', [messageChannel.port2]);
            });

        }

        function waitForSandboxToLoad () {
            return new Promise((resolve, reject)=>{
                step = addStep('Load sandbox');
                var wasOk = false;
                iframe.onload = function () {
                    resolve();
                    step.ok();
                    wasOk = true;
                }
                iframe.setAttribute('src', SANDBOX_URL);
                setTimeout(_=>{
                    if (!wasOk) {
                        step.fail();
                    }
                }, 6000);
            });
        }

        function waitForDSWRegistration () {
            step = addStep('Register SW');
            var wasOk = false;

            setTimeout(_=>{
                if (!wasOk) {
                    step.fail();
                }
            }, 4000);

            return sendMessage({
                DSWCommand: {
                    get: 'readyEvent'
                }
            }).then(result=>{
                if (result.status.registered) {
                    wasOk = true;
                    step.ok();
                } else {
                    step.fail();
                }
                addStep('Pre cache AppShell', result.status.appShell);
            });
        }

        function waitForSandboxToReload () {
            return new Promise((resolve, reject)=>{
                // we have to do it this way due to an error freezing the devTools
                // in chrome when we try to access the contentWindow in an iframe that
                // we have changed the source.
                step = addStep('Reload Sandbox');
                setTimeout(_=>{
                    var finalIframe = document.createElement('iframe');
                    var wasOk = false;
                    finalIframe.setAttribute('id', 'testPage');
                    finalIframe.onload = function(){
                        resolve();
                        step.ok();
                        wasOk = true;
                    };
                    setTimeout(_=>{
                        if (!wasOk) {
                            step.fail();
                        }
                    }, 5000);
                    var src = iframe.src;
                    finalIframe.src = src;
                    iframe.replaceWith(finalIframe);
                    iframe = finalIframe;
                }, 1000);
            });
        }

        function turnTestsOn () {
            step = addStep ('Enable test mode');
            return sendMessage({
                DSWCommand: {
                    dswUnderAutomatedTest: true
                }
            }).then(result=>{
                if (result === true) {
                    step.ok();
                } else {
                    step.fail();
                }
            });
        }

        function getDSWStatus () {
            step = addStep('Get DSW Status');
            return sendMessage({
                DSWCommand: {
                    get: 'dswStatus'
                }
            }).then(result=>{
                if (result && result.registered) {
                    return step.ok();
                }
                step.fail();
            });
        }

        var testsToRun = [];
        function addTest (text, test) {
            testsToRun.push(function (arguments) {
                return new Promise((resolve, reject)=>{
                    var currentTest = addStep(text);
                    test().then(result=>{
                        currentTest[result? 'ok': 'fail'](result);
                        resolve(result);
                    });
                })
            });
        }

        function execTests () {

            step = addStep('Testing requests');

            function* testGen () {
              while(true){
                  var test = testsToRun.shift();
                  if (test) {
                    yield test();
                  } else {
                    return;
                  }
              }
            }

            var tests = testGen();

            // let's run all the promises
            return Promise.all([...tests])
                .then(result=>{
                    step.ok();
                })
                .catch(err=>{
                    step.fail(err);
                });
        }

        function closeTests () {
            var text = '<strong>Finished:</strong>' +
                '<br/>' + (steps.ok + steps.fail) + ' tests'+
                '<br/>Tests passed: ' + steps.ok +
                '<br/>Tests failed: ' + steps.fail +
                '<br/>';
            addStep(text, steps.fail? false: true);
        }

        function validate (expected, result) {
            return new Promise((resolve, reject)=>{

                function fail (message) {
                    console.error('[ TEST_FAIL ] :: ' + (message || ''), expected, result);
                    resolve(false);
                }

                if (expected.length && result.steps.length != expected.length) {
                    return fail('Number of steps', expected, result);
                }

                if (expected.follows) {
                    // it should follow the steps in order
                    // (extra steps in between are allowed, though)
                    let nextStep = new RegExp(expected.follows.shift(), 'i');
                    result.steps.forEach(cur=>{
                        if (cur.step.match(nextStep)) {
                            nextStep = expected.follows.shift();
                        }
                    });

                    if (expected.follows.length) {
                        return fail('Did not follow all the steps in order!\nMissed steps:\n - ' + expected.follows.join('\n - ') + '\n\n');
                    }
                }

                if (expected.steps) {
                    let i = 0,
                        curStep = {};
                    try {
                        for(i in expected.steps) {

                            curStep = expected.steps[i];

                            if (i == 'last') {
                                i = result.steps.length - 1;
                            }

                            // testing for the resulting url
                            let stepData = result.steps[i].data;
                            if (curStep.url) {
                                // we check the url in the given step
                                if (stepData.url != curStep.url) {
                                    return fail('Url mismatch in step ' + i);
                                }
                            }
                            if (curStep.rule) {
                                // we check the rule name in the given step
                                if ((stepData.name || stepData.rule.name) != curStep.rule) {
                                    return fail('Rule name mismatch in step ' + i);
                                }
                            }
                            if (curStep.strategy) {
                                if (stepData.rule.strategy != curStep.strategy) {
                                    return fail('Strategy mismatch for step ' + i);
                                }
                            }
                            if (curStep.cache) {
                                if (stepData.rule.action.cache) {
                                    return fail('Step ' + i + ' should be caching');
                                }
                            }
                            if (curStep.indexeddb) {
                                if (stepData.rule.action.indexeddb) {
                                    return fail('Step ' + i + ' should have indexedDB action    ');
                                }
                            }
                        }
                    }catch(e){
                        return fail(e.message + '\nIn step ' + i);
                    }
                }
                resolve({ status: true });
            });
        }

        function assert (output, expected) {
            return new Promise((resolve, reject)=>{
                var data = traced[output.result.url];
                if (data) {
                    resolve(validate(expected, data));
                } else {
                    tracing[output.result.url] = traceData=>{
                        resolve(validate(expected, traceData));
                    };
                }
            });
        }

        addTest('Load image', function () {
            return new Promise((resolve, reject)=>{
                sendMessage({
                    DSWCommand: {
                        exec: 'click',
                        target: '#btn-img-1'
                    }
                }).then(result=>{
                    resolve(assert(result, {
                        length: 5,
                        steps: {
                            0: { url: 'http://localhost:8888/images/public/gears.png' },
                            1: { rule: 'images', strategy: 'offline-first' },
                            4: { url: 'http://localhost:8888/images/public/gears.png' }
                        }
                    }));
                })
            });
        });

        addTest('Image not found', function () {
            return new Promise((resolve, reject)=>{
                sendMessage({
                    DSWCommand: {
                        exec: 'click',
                        target: '#btn-img-2'
                    }
                }).then(result=>{
                    resolve(assert(result, {
                        follows: [
                            'Will fetch',
                            'Failed fetching',
                            'fallback',
                            'Redirecting',
                            'Result found in cache'
                        ],
                        steps: {
                            1: { rule: 'images'},
                            6: { rule: 'imageNotFound' },
                            8: { rule: 'images' },
                            'last': { url: 'http://localhost:8888/images/public/404.jpg' }
                        }
                    }));
                })
            });
        });

        addTest('Redirect image', function () {
            return new Promise((resolve, reject)=>{
                sendMessage({
                    DSWCommand: {
                        exec: 'click',
                        target: '#btn-img-3'
                    }
                }).then(result=>{
                    console.warn(result);
                    resolve(result);
                })
            });
        });

        addTest('Uncacheable image', function () {
            return new Promise((resolve, reject)=>{
                sendMessage({
                    DSWCommand: {
                        exec: 'click',
                        target: '#btn-img-4'
                    }
                }).then(result=>{
                    console.warn(result);
                    resolve(result);
                })
            });
        });







        waitForSandboxToLoad()
            .then(waitForDSWRegistration)
            .then(waitForSandboxToReload)
            .then(turnTestsOn)
            .then(getDSWStatus)
            .then(execTests)
            .then(result=>{
                closeTests()
            })
            .catch(error=>{
                if (step) {
                    step.fail();
                }
                closeTests()
            });
    </script>
</body>
</html>
